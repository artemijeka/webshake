<?php
/**
 * Created by PhpStorm.
 * User: artem
 * Date: 02.09.18
 * Time: 12:34
 */

/**
 * Создайте страницу для разлогинивания - logout.php. При переходе на неё должны удаляться cookie с ключами login и
 * password и выполняться редирект на главную страницу. В качестве ответа предоставьте полный код файла logout.php.
 * Сейчас при переходе авторизованного пользователя на страницу login.php открывается форма авторизации.
 * Сделайте предварительную проверку того, что пользователь уже авторизован. И если он является авторизованным,
 * перенаправляйте его на главную страницу. В качестве ответа на это задание предоставьте только код,
 * который вы добавили в файл login.php.
 */


/**
 * Укажите параметр $ttl в функции setcookie равным 20.
 * Запустите этот скрипт и посмотрите, что изменилось в заголовке Set-Cookie в консоли разработчика.
 * Сразу после установки cookie перейдите на страничку http://myproject.loc/viewCookies.php и убедитесь что эта cookie
 * сейчас содержится в массиве и выводится.
 * Спустя 20 секунд обновите эту страницу снова и убедитесь, что cookie пропала из массива.
 */
//setcookie('login', 'admin', 0, '/');
//setcookie('password', 'p@SsW0rd', time()+20, '/');
//var_dump($_COOKIE['login']);
//var_dump($_COOKIE['password']);
//echo 'Cookie установлены';

/**
 * Попробуйте в качестве одного из аргументов передать 0. Какой получился результат? Почему так? Дополните код так,
 * чтобы можно было передавать 0.
 *
 * Усовершенствуйте калькулятор так, чтобы он умножал и делил.
 *
 * Что произойдёт, если поделить на ноль? Добавьте обработку такой ситуации.
 *
 * Что произойдёт, если в качестве аргумента передать вместо числа строку? Сделайте так, чтобы в качестве аргументов
 * можно было отправить только числа.
 *
 * Какие ещё недостатки есть у этого кода? Как можно нарушить его работу? Что можно улучшить?
 * В комментариях пишите только содержимое файла calc.php. Код из файлов index.php и result.php приводить не нужно.
 */
/*?>
    <html>
    <head>
        <title>Калькулятор</title>
    </head>
    <body>
    <form action="/result.php">
        <input type="text" name="x1">
        <select name="operation">
            <option value="+">+</option>
            <option value="-">-</option>
            <option value="*">*</option>
            <option value="/">/</option>
        </select>
        <input type="text" name="x2">
        <input type="submit" value="Посчитать">
    </form>
    </body>
    </html>
<?php*/
/**
 * Напишите в комментариях примеры того, когда стоит использовать GET-запрос, а когда POST. Разумеется, пример поисковой
 * строки Яндекса и форму входа использовать нельзя. Можете привести примеры каких-то конкретных сайтов, где эти запросы
 * используются.
 */

/**
 * Сейчас если переданы неверные логин или пароль, выводится информация о том, что либо одно, либо другое неверно.
 * Добавьте дополнительное условие, которое будет говорить о том, что пользователь не найден, если переданный логин не
 * ‘admin’. И если пользователь не найден, то нет смысла проверять пароль, и это условие проверяться не будет.
 * Если же логин ‘admin’, но пароль не совпадает, то писать о том, что пароль неверный.
 */
//    $login = !empty($_GET['login']) ? $_GET['login'] : '';
//    $password = !empty($_GET['password']) ? $_GET['password'] : '';
//    if ($login !== 'admin') {
//        $isAuthorized = 'Пользователь не найден!';
//    }
//    elseif ($password === 'pass') {
//        $isAuthorized = 'Пользователь и пароль совпадают!';
//    }
//    else {
//        $isAuthorized = 'Пароль не верен!';
//    }
//    var_dump($_GET['login']);
/*?>
    <html>
    <head>
        <title>Результат авторизации</title>
    </head>
    <body>
    <p>
        <?= $isAuthorized; ?>
    </p>
    </body>
    </html>

<?php*/
/**
 * Есть массив чисел – [1, 3, 2]. Отсортируйте их от меньшего к большему и преобразуйте в строку, в которой значения
 * элементов массива разделяются двоеточиями. В результате должна получиться строка “1:2:3”.
 *
 * Есть массив чисел – [1, 2, 3, 4, 5]. Получите с помощью одной функции массив, в котором будут элементы исходного с
 * 1-го элемента по 3-й. В результате должен получиться массив с числами [2, 3, 4].
 *
 * Есть массив чисел – [1, 2, 5, 2, 3, 1, 6]. Получите такой массив, в котором каждое значение из исходного будет
 * содержаться только один раз. В результате должен получиться массив, содержащий числа [1, 2, 5, 3, 6].
 */
//    $arr = [1, 2, 5, 2, 3, 1, 6];
//    var_dump(array_unique($arr));

//    $arr = [1, 2, 3, 4, 5];
//    var_dump(array_slice($arr, 1, 3, true)); // true сохранили исходные индексы

//    $arr = [1, 3, 2];
//    sort($arr);
//    echo implode(':', $arr);

/**
 * Напишите функцию, принимающую на вход 2 аргумента - массив и какое-либо значение. Функция возвращает true,
 * если переданное значение присутствует в массиве и false - если нет.
 *
 * Напишите функцию, принимающую на вход 2 аргумента - массив и какое-либо значение.
 * Функция возвращает число вхождений числа в массив. Например: для массива [1, 2, 1, 3]
 * число вхождений числа "1" будет равно двум.
 */
//    $arr = [1, 5, 234, 2, 52, 235, 2];
//    $numb = 2;
//    function arrAndNumb($arr, $numb)
//    {
//        $count = 0;
//        foreach ($arr as $number) {
//            if ($number == $numb) {
//                $count++;
//            }
//        }
//        return 'Число ' . $numb . ' встречается '.$count.' раз в массиве!';
//    }
//    echo arrAndNumb($arr, $numb);
//
//    $arr = [1, 5, 234, 2, 52, 235];
//    $numb = 3;
//    function arrAndNumb($arr, $numb) {
//        if (in_array($numb, $arr)) {
//            return 'Число '.$numb.' есть в массиве!';
//        } else {
//            return 'Числа '.$numb.' нет в массиве!';
//        }
//    }
//    echo arrAndNumb($arr, $numb);

/**
 * Найдите числа от 1000 до 1000000, которые делятся на 17 без остатка.
 *
 * Найдите числа Фибоначчи меньше 100000. Числа Фибоначчи – это последовательность чисел, в которой первые два числа
 * равны 0 и 1, а каждое последующее число равно сумме двух предыдущих чисел. *
 * Должно получиться: 0, 1, 1, 2, 3, 5, 8 ...
 */

//for ($a = 0, $b = 1, $i = 0; $a <= 100000 || $b <= 100000; $i++) {
//	if ($a == 0) {
//		echo $a.'<br />';
//	}
//	if ($a < $b) {
//		$a = $a+$b;
//		echo $a.'<br />';
//	} elseif ($a >= $b) {
//		$b = $a+$b;
//		echo $b.'<br />';
//	}
//	if ($b == 1) {
//		echo $b.'<br />';
//	}
//}
//        for ($i = 1000; $i <= 1000000; $i++) {
//            if ($i % 17 == 0) {
//                while ($i <= 1000000) {
//                    echo $i . '<br />';
//                    $i+=17; // экономия ресурсов
//                }
//                break;
//            }
//        }

/**
 * С помощью цикла while создайте массив, содержащий чётные числа от 345 до 357.
 * Затем выведите элементы массива с помощью цикла foreach.
 *
 * Запустите следующий код:
 * <?php
 * while (true) {
 * echo 1;
 * }
 * К чему это привело?
 *
 * Изучите, для чего нужна директива max_execution_time в файле конфигурации php.ini и установите её равной одной
 * секунде (этот файл мы с вами уже редактировали в этом уроке, как это делать смотрите там же).
 * Снова запустите этот код.
 */
//while (true) {
//    echo 1;
//}

/**
 * Придумайте способ обойтись без использования функции count.
 */
//$carsSpeeds = [
//    95,
//    140,
//    78
//];
//
//$sumOfSpeeds = 0;
//$countOfCars = 0;
//
//foreach ($carsSpeeds as $speed) {
//    $sumOfSpeeds += $speed;
//    $countOfCars++;
//}
//$averageSpeed = $sumOfSpeeds / $countOfCars;
//echo 'Средняя скорость движения по трассе: ' . $averageSpeed;

/**
 * Создайте массив с тремя уровнями вложенности, добавьте новые элементы на этом самом глубоком уровне вложенности.
 */
//$fruits = ['fruit'=>[
//    'citrus'=>['orange', 'mandarin', 'lime'],
//    'apples'=>['green', 'red', 'golden']
//]];
//echo '<pre>';
//var_dump($fruits);
//echo '</pre>';

/**
 * Самостоятельно создайте архитектуру, описанную в статье: сделайте шапку, сайдбар, контент и футер в отдельных файлах.
 * Сделайте минимум 4 переменные для каждого из этих блоков в файле index.php и выведете их внутри этих файлов.
 *
 * Изучите официальную документацию по include и изучите как можно использовать выражения вида
 * $var = include 'file.php';
 */

//$var = include 'functions.php'; // Можно проверить подключение файла 1 или false
//var_dump($var);

//$title = 'Привет ДЗ!';
//$lang = 'ru';
//require_once('head.html');
//$headerContent = 'Голова сайта';
//$headerImg = '<img src="http://s017.radikal.ru/i425/1604/84/92a34fab7fb2.jpg" alt="" height="90px"/>';
//require_once('header.html');
//$sidebar = 'сайдБАР';
//require_once('sidebar.html');
//$content = file_get_contents(__DIR__ . '/files/content.txt');
//require_once('content.html');
//$footer = 'НОГИ САЙТА';
//require_once('footer.html');

/**
 * V Напишите функцию, которая будет принимать на вход 3 аргумента с типом float и возвращать минимальное значение.
 *
 * V Напишите функцию, которая принимает на вход два аргумента по ссылкам и умножает каждый из них на 2.
 *
 * V Напишите функцию, считающую факториал числа (произведение целых чисел от единицы до переданного). Ну разумеется, тут никуда без рекурсии =)
 *
 * V Напишите функцию, которая будет выводить на экран целые числа от 0 до переданного значения.
 * И да, тут тоже не обойтись без рекурсии, это задание повышенной сложности. Кто справится и первым напишет
 * верное решение в комментах – тот красавчик и получит от проекта небольшой бонус. UPD: первым справился человек
 * с ником omk. Вариант его решения вы можете увидеть в комментариях.
 */

//// Не моя (omk):
//function numbers(int $x) { // 2
//    if ($x == 0) { // 2n 1n 0y
//        echo $x; // 0
//        return true; // функция на этом завершается положительно
//    }
//    $y = numbers($x - 1); // 1 0
//    echo ', ' . $x; // , 2, 1 - наоборот
//    return $y; // вернуться к вызову функции |
//}
//numbers(15);

//    function echoNumberBy0ToArg_v1($arg)
//    {
//        for ($i = 0; $arg >= $i; $i++) {
//            echo $i . '<br />';
//        }
//    }
//    echoNumberBy0ToArg_v1(2);

/**
 * Сначала идет проработка вызова функции в самой себе.
 * А только потом проработка всех выводов echo $arg, все равно какая-то пелена, что за правила отработки echo и функции
 * внутри функции? Почему echo потом отрабатывает в обратном порядке ведь числа поступали в порядке 3 2 1 0, а он их
 * после отработки выводит 0 1 2 3, интересно.
 */
//    function numberBy0ToArg_v2($arg)
//    {
//        if ($arg >= 0) {
//            $arg - numberBy0ToArg_v2($arg - 1) . '<br />';
//            echo $arg;
//        }
//    }
//
//    numberBy0ToArg_v2(3);

/**
 * 3 - а где обработка случая, когда не больше единицы? Вам повезло, что null преобразовался в 0.
 * Факториал - это произведение а не сумма.
 */
//    function factorialBy1ToArg($arg) // 4 3 2 6 24 120
//    {
//        if ($arg >= 1) {
//            if ($arg > 2) { // 4 3 2
//                $arg *= factorialBy1ToArg($arg - 1); // 12 6
//            }
//            return $arg; // 2 6 24 120
//        } else {
//            echo 'Нельзя вычислить факториал от числа меньше 1-ого';
//        }
//    }

//    echo factorialBy1ToArg(5); // 120

//    $a = 4;
//    $b = 3;
//
//    function twoArgMultiplyBy2(&$a, &$b)
//    {
//        $a = $a * 2;
//        $b = $b * 2;
//    }
//
//    twoArgMultiplyBy2($a, $b);
//    var_dump($a, $b);

//    function smallOfThreeArg(float $a, float $b, float $c)
//    {
//        if ($a < $b) {
//            if ($a < $c) {
//                return $a;
//            }
//            return $c;
//        }
//        return $b;
//    }
//    echo smallOfThreeArg(5.2, 8.6, 3.6);

/**
 * Попробуйте следующие условия:
 *
 * if (‘string’) {echo ‘Условие выполнилось’;}
 * if (0) {echo ‘Условие выполнилось’;}
 * if (null) {echo ‘Условие выполнилось’;}
 * if (5) {echo ‘Условие выполнилось’;}
 *
 * Объясните результат.
 *
 * С помощью тернарного оператора определите, является ли число чётным или нечётным и выведите результат.
 */

// * x= 2
// * n= 3
// * x= 2
// * n= 2
// * x= 2
// * n= 1
// * 8

//function power(int $x, int $n)
//{
//    print "<br />";
//    // Если сейчас степень равна единице, то возвращаем само это число
//    if ($n == 1) {
//        return $x;
//    }
//
//    // В остальных случаях - умножаем число на возведённое в степень n - 1 и возвращаем его
//    return $x * power($x, $n - 1);
//}
//
//echo power(2, 3);
